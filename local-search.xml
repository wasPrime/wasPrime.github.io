<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见排序及时间复杂度</title>
    <link href="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>必知必会排序方式</p></blockquote><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度 $O(n ^ 2)$</p><pre><code class="lang-Python">def BubbleSort(nums: List[int]) -&gt; None:    n = len(nums)    for i in range(n - 1):        for j in range(n - i - 1):            if nums[j] &gt; nums[j + 1]:                nums[j], nums[j + 1] = nums[j + 1], nums[j]</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="顺序插入"><a href="#顺序插入" class="headerlink" title="顺序插入"></a>顺序插入</h3><p>时间复杂度 $O(n ^ 2)$</p><pre><code class="lang-Python">def InsertSort(nums: List[int]) -&gt; None:    n = len(nums)    for i in range(n):        temp = nums[i]        j = i - 1        while j &gt;= 0 and nums[j] &gt; temp:            nums[j + 1] = nums[j]            j -= 1        nums[j + 1] = temp</code></pre><h3 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h3><p>时间复杂度 $O(n ^ 2)$ （内循环查找复杂度为 $O(n\log_2n)$，移位复杂度为 $O(n)$，故内循环总复杂度为 $O(n ^ 2)$）</p><pre><code class="lang-Python">def HInsertSort(nums: List[int]) -&gt; None:    n = len(nums)    for i in range(n):        temp = nums[i]        low, high = 0, i - 1        while low &lt;= high:            mid = low + (high - low) // 2            if nums[mid] &gt; temp:                high = mid - 1            else:                low = mid + 1        for j in range(i - 1, high, -1):            nums[j + 1] = nums[j]        nums[high + 1] = temp</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>时间复杂度比 $O(n ^ 2)$ 要好</p><pre><code class="lang-Python">def ShellSort(nums: List[int]) -&gt; None:    n = len(nums)    dk = n // 2    # 外层步长控制    while dk &gt;= 1:        # 开始插入排序        for i in range(dk, n):            # 满足条件则交换            while i &gt;= dk and nums[i]&lt;nums[i-dk]:                nums[i], nums[i-dk] = nums[i-dk], nums[i]                i-=dk        dk //= 2</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>时间复杂度 $O(n\log_2n)$</p><pre><code class="lang-Python">def QuickSort(nums: List[int], low: int, high: int) -&gt; None:    def partition(nums: List[int], low: int, high: int) -&gt; int:        pivot = nums[low]        while low &lt; high:            while low &lt; high and nums[high] &gt;= pivot:                high -= 1            nums[low] = nums[high]            while low &lt; high and nums[low] &lt;= pivot:                low += 1            nums[high] = nums[low]        nums[low] = pivot        return low    if low &lt; high:        pos = partition(nums, low, high)        QuickSort(nums, low, pos - 1)        QuickSort(nums, pos + 1, high)</code></pre><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>时间复杂度 $O(n ^ 2)$</p><pre><code class="lang-Python">def SelectSort(nums: List[int]) -&gt; None:    n = len(nums)    for i in range(n - 1):        min = i        for j in range(i + 1, n):            if nums[j] &lt; nums[min]:                min = j        if min != i:            nums[i], nums[min] = nums[min], nums[i]</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>时间复杂度 $O(n\log_2n)$</p><pre><code class="lang-Python">def HeapSort(nums: List[int]) -&gt; None:    # 调整为大根堆    def adjust(nums: List[int], length: int, index: int) -&gt; None:        left, right = 2 * index + 1, 2 * index + 2  # index的左右子节点        maxIdx = index        if left &lt; length and nums[left] &gt; nums[maxIdx]:            maxIdx = left        if right &lt; length and nums[right] &gt; nums[maxIdx]:            maxIdx = right        if maxIdx != index:            nums[maxIdx], nums[index] = nums[index], nums[maxIdx]            adjust(nums, length, maxIdx)    n = len(nums)    for i in range(n // 2 - 1, -1, -1):        adjust(nums, n, i)    for i in range(n - 1, 0, -1):        nums[0], nums[i] = nums[i], nums[0]        adjust(nums, i, 0)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统整理</title>
    <link href="/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/"/>
    <url>/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>面试常见的操作系统考点</p></blockquote><a id="more"></a><h2 id="说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"><a href="#说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的" class="headerlink" title="说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"></a>说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的</h2><p><strong>基本概念：</strong></p><ul><li><p><code>进程</code> 是对运行时程序的 <code>封装</code>，<strong>是系统进行资源调度和分配的的基本单位</strong>，实现了操作系统的并发；</p></li><li><p><code>线程</code> 是进程的子任务，是<strong>CPU调度和分派的基本单位</strong>，用于保证程序的实时性，实现进程内部的并发；线程是<strong>操作系统可识别的最小执行和调度单位</strong>。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p></li></ul><p><strong>区别：</strong></p><ol><li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p></li><li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。<strong>同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。</strong> 但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p></li><li><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位；</strong></p></li><li><p><code>系统开销</code>：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p></li><li><p><code>通信</code>：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p></li><li><p>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p></li><li><p>进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉</p></li><li><p>进程适应于多核、多机分布；线程适用于多核。</p></li></ol><p><strong>进程间通信的方式：</strong></p><p>进程间通信主要包括 <code>管道</code>、<code>系统IPC（包括消息队列、信号量、信号、共享内存等）</code>、以及 <code>套接字socket</code>。</p><ol><li><p><strong>管道</strong></p><p> <code>管道</code> 主要包括 <code>无名管道</code> 和 <code>命名管道</code>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><ol><li><p><strong>普通管道PIPE</strong></p><ol><li><p>它是 <code>半双工</code> 的（即数据只能在一个方向上流动），具有固定的读端和写端；</p></li><li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）；</p></li><li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></li></ol></li><li><p><strong>命名管道FIFO</strong></p><ol><li><p>FIFO可以在无关的进程之间交换数据</p></li><li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p></li></ol></li></ol></li><li><p><strong>系统IPC</strong></p><ol><li><p><strong>消息队列</strong></p><p>  <code>消息队列</code>，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。（消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点）具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>  <strong>特点：</strong></p><ol><li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p></li><li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p></li><li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p></li></ol></li><li><p><strong>信号量semaphore</strong></p><p>  <code>信号量（semaphore）</code>与已经介绍过的 <code>IPC</code> 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>  <strong>特点：</strong></p><ol><li><p>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p></li><li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p></li><li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p></li><li><p>支持信号量组。</p></li></ol></li><li><p><strong>信号signal</strong></p><p>  <code>信号</code>是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></li><li><p><strong>共享内存（Shared Memory）</strong></p><p>  它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p><p>  <strong>特点：</strong></p><ol><li><p>共享内存是最快的一种IPC，因为进程是直接对内存进行存取；</p></li><li><p>因为多个进程可以同时操作，所以需要进行同步；</p></li><li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p></li></ol></li></ol></li><li><p><strong>套接字SOCKET</strong></p><p> <code>socket</code> 也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><p> 线程间通信的方式:</p><p> <code>临界区</code>：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p> <code>互斥量Synchronized/Lock</code>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p> <code>信号量Semphare</code>：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p> <code>事件（信号），Wait/Notify</code>：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p></li></ol><h2 id="说一说Linux虚拟地址空间"><a href="#说一说Linux虚拟地址空间" class="headerlink" title="说一说Linux虚拟地址空间"></a>说一说Linux虚拟地址空间</h2><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。<br>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程「创建」了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如 <code>.text</code>、<code>.data</code> 段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如 <code>malloc</code> 时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><ul><li><p><strong>虚拟内存的好处：</strong></p><ol><li><p>扩大地址空间；</p></li><li><p><code>内存保护</code>：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p></li><li><p><code>公平内存分配</code>：采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p></li><li><p>当进程通信时，可采用虚存共享的方式实现。</p></li><li><p>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存。</p></li><li><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高。</p></li><li><p>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。</p></li></ol></li><li><p><strong>虚拟内存的代价：</strong></p><ol><li><p>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存。</p></li><li><p>虚拟地址到物理地址的转换，增加了指令的执行时间。</p></li><li><p>页面的换入换出需要磁盘I/O，这是很耗时的。</p></li><li><p>如果一页中只有一部分数据，会浪费内存。</p></li></ol></li></ul><h2 id="说一说操作系统中的程序的内存结构"><a href="#说一说操作系统中的程序的内存结构" class="headerlink" title="说一说操作系统中的程序的内存结构"></a>说一说操作系统中的程序的内存结构</h2><p><img src="/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/内存结构.png" srcset="/img/loading.gif" alt="内存结构"></p><p>一个程序本质上都是由 <code>BSS段</code>、<code>data段</code>、<code>text段</code> 三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p><p><strong>BSS段（未初始化数据区）：</strong> 通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p><p><strong>数据段：</strong> 存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p><p><strong>代码段：</strong> 存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p><p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p><p>BSS段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p><p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p><p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p><p>可执行程序在运行时又多出两个区域：栈区和堆区。</p><p><strong>栈区：</strong> 由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p><p><strong>堆区：</strong> 用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>]]></content>
    
    
    <categories>
      
      <category>面经知识汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语言基础</title>
    <link href="/2020/03/21/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/21/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>面试常见的C++语言基础</p></blockquote><a id="more"></a><h2 id="基本语言"><a href="#基本语言" class="headerlink" title="基本语言"></a>基本语言</h2><h3 id="C-和C的区别"><a href="#C-和C的区别" class="headerlink" title="C++和C的区别"></a>C++和C的区别</h3><ul><li><p>设计思想上：<br>C++是面向对象的语言，而C是面向过程的结构化编程语言</p></li><li><p>语法上：</p><ul><li>C++具有封装、继承和多态三种特性；</li><li>C++相比C，增加多许多类型安全的功能，比如强制类型转换；</li><li>C++支持范式编程，比如 <code>模板类</code>、<code>函数模板</code> 等。</li></ul></li></ul><h3 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h3><ol><li><p><strong>全局静态变量</strong><br>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为 <code>0</code>（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p></li><li><p><strong>局部静态变量</strong><br>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br>内存中的位置：<code>静态存储区</code><br>初始化：未经初始化的局部静态变量会被自动初始化为 <code>0</code>（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p></li><li><p><strong>静态函数</strong><br>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；<br>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p></li><li><p><strong>类的静态成员</strong><br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p></li><li><p><strong>类的静态函数</strong><br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<code>&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</code></p></li></ol><ul><li>加了static关键字的全局变量只能在本文件中使用。例如在 <code>a.c</code> 中定义了 <code>static int a=10;</code> 那么在 <code>b.c</code> 中用 <code>extern int a</code> 是拿不到a的值的，a的作用域只在 <code>a.c</code> 中。</li><li>static定义的静态局部变量分配在 <code>数据段</code> 上，普通的局部变量分配在 <code>栈</code> 上，会因为函数栈帧的释放而被释放掉。</li><li>对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了 <code>this</code> 指针了，必须通过类名才能访问。</li></ul><h3 id="C-中四种cast转换"><a href="#C-中四种cast转换" class="headerlink" title="C++中四种cast转换"></a>C++中四种cast转换</h3><p>C++中四种类型转换是：<code>static_cast</code>，<code>dynamic_cast</code>，<code>const_cast</code>，<code>reinterpret_cast</code></p><ol><li><p><code>const_cast</code><br>用于将const变量转为非const。</p></li><li><p><code>static_cast</code><br>用于各种隐式转换，比如非const转const，void*转指针等，static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知。</p></li><li><p><code>dynamic_cast</code><br>用于动态类型转换。<strong>只能用于含有虚函数的类</strong>，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 <code>NULL</code>，对于引用抛异常。要深入了解内部转换的原理。<br>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p><ul><li>向上转换：指的是子类向基类的转换。</li><li>向下转换：指的是基类向子类的转换。</li></ul></li><li><p><code>reinterpret_cast</code><br>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p></li><li><p>为什么不使用C的强制转换？<br>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p></li></ol><h3 id="C-中的四个智能指针-smart-pointer：shared-ptr，unique-ptr，weak-ptr，auto-ptr"><a href="#C-中的四个智能指针-smart-pointer：shared-ptr，unique-ptr，weak-ptr，auto-ptr" class="headerlink" title="C++中的四个智能指针 smart pointer：shared_ptr，unique_ptr，weak_ptr，auto_ptr"></a>C++中的四个智能指针 <code>smart pointer</code>：<code>shared_ptr</code>，<code>unique_ptr</code>，<code>weak_ptr</code>，<code>auto_ptr</code></h3><p>C++里面的四个智能指针：auto_ptr，shared_ptr，weak_ptr，unique_ptr 其中后三个是C++11支持，并且第一个已经被C++11弃用。</p><p><strong>为什么要使用智能指针？</strong><br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为 <strong>智能指针就是一个类</strong>，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p><ol><li><p><code>auto_ptr</code>（C++98的方案，C++11已经抛弃）采用所有权模式。</p><pre><code class="lang-C++"> auto_ptr&lt;string&gt; p1 (new string (&quot;I reigned lonely as a cloud.&quot;)); auto_ptr&lt;string&gt; p2; p2 = p1; //auto_ptr不会报错.</code></pre><p> 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p></li><li><p><code>unique_ptr</code>（替换auto_ptr）</p><p> unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p><p> 采用所有权模式，还是上面那个例子</p><pre><code class="lang-C++"> unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;));  //#4 unique_ptr&lt;string&gt; p4；                       //#5 p4 = p3;//此时会报错！！</code></pre><p> 编译器认为 <code>p4 = p3</code> 非法，避免了 <code>p3</code> 不再指向有效数据的问题。因此，<code>unique_ptr</code> 比 <code>auto_ptr</code> 更安全。</p><p> 另外 <code>unique_ptr</code> 还有更聪明的地方：当程序试图将一个 <code>unique_ptr</code> 赋值给另一个时，如果源 <code>unique_ptr</code> 是个临时右值，编译器允许这么做；如果源 <code>unique_ptr</code> 将存在一段时间，编译器将禁止这么做，比如：</p><pre><code class="lang-C++"> unique_ptr&lt;string&gt; pu1(new string (&quot;hello world&quot;)); unique_ptr&lt;string&gt; pu2; pu2 = pu1;                                      // #1 not allowed unique_ptr&lt;string&gt; pu3; pu3 = unique_ptr&lt;string&gt;(new string (&quot;You&quot;));   // #2 allowed</code></pre><p> 其中 <code>#1</code> 留下悬挂的 <code>unique_ptr(pu1)</code>，这可能导致危害。而 <code>#2</code> 不会留下悬挂的 <code>unique_ptr</code>，因为它调用 <code>unique_ptr</code> 的构造函数，该构造函数创建的临时对象在其所有权让给 <code>pu3</code> 后就会被销毁。这种随情况而已的行为表明，<code>unique_ptr</code> 优于允许两种赋值的 <code>auto_ptr</code>。</p><p> 注：如果确实想执行类似与 <code>#1</code> 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数 <code>std::move()</code>，让你能够将一个 <code>unique_ptr</code> 赋给另一个。例如：</p><pre><code class="lang-C++"> unique_ptr&lt;string&gt; ps1, ps2; ps1 = demo(&quot;hello&quot;); ps2 = move(ps1); ps1 = demo(&quot;alexia&quot;); cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</code></pre></li><li><p><code>shared_ptr</code></p><p> <code>shared_ptr</code> 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 <code>use_count()</code> 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 <code>auto_ptr</code>，<code>unique_ptr</code>，<code>weak_ptr</code> 来构造。当我们调用 <code>release()</code> 时，当前指针会释放资源所有权，计数减一。当计数等于 <code>0</code> 时，资源会被释放。</p><p> <code>shared_ptr</code> 是为了解决 <code>auto_ptr</code> 在对象所有权上的局限性(<code>auto_ptr</code> 是独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针。</p><p> <strong>成员函数：</strong><br> <code>use_count</code> 返回引用计数的个数；<br> <code>unique</code> 返回是否是独占所有权（<code>use_count</code> 为 1）；<br> <code>swap</code> 交换两个 <code>shared_ptr</code> 对象(即交换所拥有的对象)；<br> <code>reset</code> 放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少；<br> <code>get</code> 返回内部对象(指针)，由于已经重载了 <code>()</code> 方法， 因此和直接使用对象是一样的，如 <code>shared_ptr&lt;int&gt; sp(new int(1));</code> <code>sp</code> 与 <code>sp.get()</code> 是等价的。</p></li><li><p><code>weak_ptr</code></p><p> <code>weak_ptr</code> 是一种不控制对象生命周期的智能指针， 它指向一个 <code>shared_ptr</code> 管理的对象。进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code>。<code>weak_ptr</code> 只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 工作， 它只可以从一个 <code>shared_ptr</code> 或另一个 <code>weak_ptr</code> 对象构造，<strong>它的构造和析构不会引起引用记数的增加或减少</strong>。<code>weak_ptr</code> 是用来解决 <code>shared_ptr</code> 相互引用时的死锁问题，如果说两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 <code>shared_ptr</code> 之间可以相互转化，<code>shared_ptr</code> 可以直接赋值给它，它可以通过调用 <code>lock</code> 函数来获得 <code>shared_ptr</code>。</p><pre><code class="lang-C++"> class B; class A { public:     shared_ptr&lt;B&gt; pb_;     ~A()     {         cout &lt;&lt; &quot;A delete&quot; &lt;&lt; endl;     } }; class B { public:     shared_ptr&lt;A&gt; pa_;     ~B()     {         cout &lt;&lt; &quot;B delete&quot; &lt;&lt; endl;     } }; void fun() {     shared_ptr&lt;B&gt; pb(new B());     shared_ptr&lt;A&gt; pa(new A());     pb-&gt;pa_ = pa;     pa-&gt;pb_ = pb;     cout &lt;&lt; pb.use_count() &lt;&lt; endl;     cout &lt;&lt; pa.use_count() &lt;&lt; endl; } int main() {     fun();     return 0; }</code></pre><p> 可以看到 <code>fun</code> 函数中 <code>pa</code>，<code>pb</code> 之间互相引用，两个资源的引用计数为 <code>2</code>，当要跳出函数时，智能指针 <code>pa</code>，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code>，导致跳出函数时资源没有被释放（<code>A</code> <code>B</code> 的析构函数没有被调用），如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 <code>A</code> 里面的 <code>shared_ptr pb_;</code> 改为 <code>weak_ptr pb_;</code> 运行结果如下：</p><pre><code class="lang-C++"> 1 2 B delete A delete</code></pre><p> 这样的话，资源 <code>B</code> 的引用开始就只有 <code>1</code>，当 <code>pb</code> 析构时，<code>B</code> 的计数变为 <code>0</code>，<code>B</code> 得到释放，<code>B</code> 释放的同时也会使 <code>A</code> 的计数减一，同时 <code>pa</code> 析构时使 <code>A</code> 的计数减一，那么 <code>A</code> 的计数为 <code>0</code>，<code>A</code> 得到释放。</p><p> 注意的是我们不能通过 <code>weak_ptr</code> 直接访问对象的方法，比如 <code>B</code> 对象中有一个方法 <code>print()</code>，我们不能这样访问，<code>pa-&gt;pb_-&gt;print();</code> 英文 <code>pb_</code> 是一个 <code>weak_ptr</code>，应该先把它转化为 <code>shared_ptr</code>，如：<code>shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</code></p></li></ol><h3 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h3><div class="table-container"><table><thead><tr><th style="text-align:center">指针</th><th style="text-align:center">数组</th></tr></thead><tbody><tr><td style="text-align:center">保存数据的地址</td><td style="text-align:center">保存数据</td></tr><tr><td style="text-align:center">间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td><td style="text-align:center">直接访问数据</td></tr><tr><td style="text-align:center">通常用于动态的数据结构</td><td style="text-align:center">通常用于固定数目且数据类型相同的元素</td></tr><tr><td style="text-align:center">通过 <code>malloc</code> 分配内存，<code>free</code> 释放内存</td><td style="text-align:center">隐式的分配和删除</td></tr><tr><td style="text-align:center">通常指向匿名数据，操作匿名函数</td><td style="text-align:center">自身即为数据名</td></tr></tbody></table></div><h3 id="野指针是什么"><a href="#野指针是什么" class="headerlink" title="野指针是什么"></a>野指针是什么</h3><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。</p><h3 id="介绍一下C-中的智能指针"><a href="#介绍一下C-中的智能指针" class="headerlink" title="介绍一下C++中的智能指针"></a>介绍一下C++中的智能指针</h3><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++11中最常用的智能指针类型为 <code>shared_ptr</code>，它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为 <code>0</code> 时，智能指针才会自动释放引用的内存资源。对 <code>shared_ptr</code> 进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过 <code>make_shared</code> 函数或者通过构造函数传入普通指针。并可以通过 <code>get</code> 函数获得普通指针。</p><h3 id="回答一下智能指针有没有内存泄露的情况"><a href="#回答一下智能指针有没有内存泄露的情况" class="headerlink" title="回答一下智能指针有没有内存泄露的情况"></a>回答一下智能指针有没有内存泄露的情况</h3><p>当两个对象相互使用一个 <code>shared_ptr</code> 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p><h3 id="智能指针的内存泄漏如何解决"><a href="#智能指针的内存泄漏如何解决" class="headerlink" title="智能指针的内存泄漏如何解决"></a>智能指针的内存泄漏如何解决</h3><p>为了解决循环引用导致的内存泄漏，引入了 <code>weak_ptr</code> 弱指针，<code>weak_ptr</code> 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但 <strong>不指向引用计数的共享内存</strong>，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><h3 id="c-中的引用和指针"><a href="#c-中的引用和指针" class="headerlink" title="c++中的引用和指针"></a>c++中的引用和指针</h3><p><strong>定义：</strong></p><ol><li><p><code>引用</code>：<br>C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：<code>类型标识符 &amp;引用名=目标变量名;</code>引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用 <code>&amp;</code> 代替了 <code>*</code>。</p></li><li><p><code>指针</code>：</p></li></ol><p>指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为「指针」。意思是通过它能找到以它为地址的内存单元。</p><p><strong>区别：</strong></p><ol><li><p>指针有自己的一块空间，而引用只是一个别名；</p></li><li><p>使用 <code>sizeof</code> 看一个指针的大小是 <code>4</code>，而引用则是被引用对象的大小；</p></li><li><p>指针可以被初始化为 <code>NULL</code>，而引用必须被初始化且必须是一个已有对象的引用；</p></li><li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p></li><li><p>可以有const指针，但是没有const引用；</p></li><li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p></li><li><p>指针可以有多级指针（如**p），而引用只有一级；</p></li><li><p>指针和引用使用++运算符的意义不一样；</p></li><li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p></li></ol><h3 id="为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点：虚函数-析构函数"><a href="#为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点：虚函数-析构函数" class="headerlink" title="为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点：虚函数 析构函数"></a>为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点：<code>虚函数</code> <code>析构函数</code></h3><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><h3 id="说一下函数指针"><a href="#说一下函数指针" class="headerlink" title="说一下函数指针"></a>说一下函数指针</h3><ol><li><p><strong>定义：</strong><br> 函数指针是指向函数的指针变量。</p><p> 函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p><p> C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p></li><li><p><strong>用途：</strong><br> 调用函数和做函数的参数，比如回调函数。</p></li><li><p><strong>示例：</strong></p><pre><code class="lang-C++"> char *fun(char *p) {...} // 函数fun char *(*pf)(char *p);    // 函数指针pf pf = fun;                // 函数指针pf指向函数fun pf(p);                   // 通过函数指针pf调用函数fun</code></pre></li></ol><h3 id="说一下fork函数"><a href="#说一下fork函数" class="headerlink" title="说一下fork函数"></a>说一下fork函数</h3><p>Fork：创建一个和当前进程映像一样的进程可以通过 <code>fork()</code> 系统调用：</p><pre><code class="lang-C++">#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void);</code></pre><p>成功调用 <code>fork()</code> 会创建一个新的进程，它几乎与调用 <code>fork()</code> 的进程一模一样，这两个进程都会继续运行。在子进程中，成功的 <code>fork()</code> 调用会返回 <code>0</code>；在父进程中 <code>fork()</code> 返回子进程的 <code>pid</code>。如果出现错误，<code>fork()</code> 返回一个负值。</p><p>最常见的 <code>fork()</code> 用法是创建一个新的进程，然后使用 <code>exec()</code> 载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种「派生加执行」的方式是很常见的。</p><p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p><h3 id="说一下C-中析构函数的作用"><a href="#说一下C-中析构函数的作用" class="headerlink" title="说一下C++中析构函数的作用"></a>说一下C++中析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。<br>析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如 <code>~stud()</code>，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p><p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p><p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p><p>类析构顺序：</p><ol><li>派生类本身的析构函数；</li><li>对象成员析构函数；</li><li>基类析构函数。</li></ol><p>值得一提的是，析构函数和构造函数的调用顺序相反。</p><h3 id="说一下静态函数和虚函数的区别"><a href="#说一下静态函数和虚函数的区别" class="headerlink" title="说一下静态函数和虚函数的区别"></a>说一下静态函数和虚函数的区别</h3><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。</p><h3 id="说一说重载和覆盖"><a href="#说一说重载和覆盖" class="headerlink" title="说一说重载和覆盖"></a>说一说重载和覆盖</h3><ul><li><code>重载</code>：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中。</li><li><code>重写</code>：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。</li></ul><h3 id="说一说strcpy和strlen"><a href="#说一说strcpy和strlen" class="headerlink" title="说一说strcpy和strlen"></a>说一说strcpy和strlen</h3><ul><li><p>strcpy是字符串拷贝函数，原型：</p><pre><code class="lang-C++">  char *strcpy(char* dest, const char *src);</code></pre><p>  从 <code>src</code> 逐字节拷贝到 <code>dest</code>，直到遇到 <code>&#39;\0&#39;</code> 结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞，安全版本是 <code>strncpy</code> 函数。</p></li><li><p><code>strlen</code> 函数是计算字符串长度的函数，返回从开始到 <code>&#39;\0&#39;</code> 之间的字符个数。</p></li></ul><h3 id="说一说你理解的虚函数和多态"><a href="#说一说你理解的虚函数和多态" class="headerlink" title="说一说你理解的虚函数和多态"></a>说一说你理解的虚函数和多态</h3><p>多态的实现主要分为 <code>静态多态</code> 和 <code>动态多态</code>，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了 <code>virtual</code> 关键字的函数，<strong>在子类中重写时候不需要加virtual也是虚函数</strong>。<br><strong>虚函数的实现：</strong> 在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p><h3 id="说一说-i和i-的实现"><a href="#说一说-i和i-的实现" class="headerlink" title="说一说++i和i++的实现"></a>说一说++i和i++的实现</h3><ul><li><p>++i 实现：</p><pre><code class="lang-C++">  int&amp; int::operator++()  {      *this += 1;      return *this;  }</code></pre></li><li><p>i++ 实现：</p><pre><code class="lang-C++">  const int int::operator++(int)  {      int oldValue = *this;      ++(*this);      return oldValue;  }</code></pre></li></ul><h3 id="写个函数在main函数执行前先运行"><a href="#写个函数在main函数执行前先运行" class="headerlink" title="写个函数在main函数执行前先运行"></a>写个函数在main函数执行前先运行</h3><p>有2种方式：</p><ol><li><p>法1</p><pre><code class="lang-C"> __attribute((constructor))void before() {     printf(&quot;before main\n&quot;); }</code></pre></li><li><p>法2</p><p> 在C++中，也利用全局变量和构造函数的特性，通过全局变量的构造函数在 <code>main()</code> 函数之前执行</p><pre><code class="lang-C++"> class BeforeMain { public:     BeforeMain(); }; BeforeMain::BeforeMain() {     cout &lt;&lt; &quot;Before main&quot; &lt;&lt; endl; } BeforeMain bM; // 利用全局变量和构造函数的特性，通过全局变量的构造函数执行</code></pre></li></ol><h3 id="有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello"><a href="#有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello" class="headerlink" title="有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello"></a>有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello</h3><pre><code class="lang-C++">for (int i = 0; i &lt; 20; i--)    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;</code></pre><p>修改后：</p><pre><code class="lang-C++">for (int i = 0; i + 20; i--)    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;</code></pre><h3 id="以下四行代码的区别是什么"><a href="#以下四行代码的区别是什么" class="headerlink" title="以下四行代码的区别是什么"></a>以下四行代码的区别是什么</h3><pre><code class="lang-C++">const char * arr = &quot;123&quot;;char * brr = &quot;123&quot;;const char crr[] = &quot;123&quot;;char drr[] = &quot;123&quot;;</code></pre><pre><code class="lang-C++">//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样const char * arr = &quot;123&quot;;//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改&quot;123&quot;的值char * brr = &quot;123&quot;;//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区const char crr[] = &quot;123&quot;;//字符串123保存在栈区，可以通过drr去修改char drr[] = &quot;123&quot;;</code></pre><h3 id="请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置"><a href="#请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置" class="headerlink" title="请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置"></a>请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置</h3><p>对于 <code>局部常量</code>，存放在 <code>栈区</code>；对于 <code>全局常量</code>，编译期一般不分配内存，放在 <code>符号表</code> 中以提高访问效率；<code>字面值常量</code>，比如字符串，放在 <code>常量区</code>。</p><h3 id="如果同时定义了两个函数，一个带const，一个不带，会有问题吗"><a href="#如果同时定义了两个函数，一个带const，一个不带，会有问题吗" class="headerlink" title="如果同时定义了两个函数，一个带const，一个不带，会有问题吗"></a>如果同时定义了两个函数，一个带const，一个不带，会有问题吗</h3><p>当这两个函数作为普通的函数时，编译会报错，无法仅按返回类型区分两个函数；<br>当这两个函数作为类的成员函数时，是没有问题的。</p><pre><code class="lang-C++">class A{public:    void f()    {        cout&lt;&lt;&quot;non const&quot;&lt;&lt;endl;    }    void f() const    {        cout&lt;&lt;&quot; const&quot;&lt;&lt;endl;    }};//微软笔试第二题正是考这个，const 对象调用f() const，非const对象调用 f()</code></pre><h3 id="C-为什么不可以同时用const和static修饰成员函数"><a href="#C-为什么不可以同时用const和static修饰成员函数" class="headerlink" title="C++为什么不可以同时用const和static修饰成员函数"></a>C++为什么不可以同时用const和static修饰成员函数</h3><p>C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p><h3 id="说一说C-函数栈空间的最大值"><a href="#说一说C-函数栈空间的最大值" class="headerlink" title="说一说C++函数栈空间的最大值"></a>说一说C++函数栈空间的最大值</h3><p>默认是 <code>1M</code>，不过可以调整。</p><h3 id="说一说extern”C”"><a href="#说一说extern”C”" class="headerlink" title="说一说extern”C”"></a>说一说extern”C”</h3><p>C++调用C函数需要extern C，因为C语言没有函数重载。</p><h3 id="new-delete-与-malloc-free-的区别是什么"><a href="#new-delete-与-malloc-free-的区别是什么" class="headerlink" title="new/delete 与 malloc/free 的区别是什么"></a><code>new/delete</code> 与 <code>malloc/free</code> 的区别是什么</h3><p>首先，<code>new/delete</code> 是C++的关键字，而 <code>malloc/free</code> 是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数。</p><h3 id="说说你了解的-RTTI"><a href="#说说你了解的-RTTI" class="headerlink" title="说说你了解的 RTTI"></a>说说你了解的 <code>RTTI</code></h3><p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid，VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。</p><h3 id="说说虚函数表具体是怎样实现运行时多态的"><a href="#说说虚函数表具体是怎样实现运行时多态的" class="headerlink" title="说说虚函数表具体是怎样实现运行时多态的"></a>说说虚函数表具体是怎样实现运行时多态的</h3><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p><h3 id="说说C语言是怎么进行函数调用的"><a href="#说说C语言是怎么进行函数调用的" class="headerlink" title="说说C语言是怎么进行函数调用的"></a>说说C语言是怎么进行函数调用的</h3><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p><h3 id="说一说-select"><a href="#说一说-select" class="headerlink" title="说一说 select"></a>说一说 <code>select</code></h3><p>select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select，当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大。</p><h3 id="说说-fork，wait，exec-函数"><a href="#说说-fork，wait，exec-函数" class="headerlink" title="说说 fork，wait，exec 函数"></a>说说 <code>fork</code>，<code>wait</code>，<code>exec</code> 函数</h3><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写时拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回 <code>0</code>。调用了 <code>wait</code> 的父进程将会发生阻塞，直到有子进程状态改变，执行成功返回 <code>0</code>，错误返回 <code>-1</code>。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回- <code>1</code>。</p><h2 id="容器和算法"><a href="#容器和算法" class="headerlink" title="容器和算法"></a>容器和算法</h2><h3 id="说一下-map-和-set-有什么区别，分别又是怎么实现的"><a href="#说一下-map-和-set-有什么区别，分别又是怎么实现的" class="headerlink" title="说一下 map 和 set 有什么区别，分别又是怎么实现的"></a>说一下 <code>map</code> 和 <code>set</code> 有什么区别，分别又是怎么实现的</h3><p><code>map</code> 和 <code>set</code> 都是C++的关联容器，其底层实现都是红黑树（<code>RB-Tree</code>）。由于 <code>map</code> 和 <code>set</code> 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 <code>map</code> 和 <code>set</code> 的操作行为，都只是转调 <code>RB-tree</code> 的操作行为。</p><p><code>map</code> 和 <code>set</code> 区别在于：</p><ol><li><p><code>map</code> 中的元素是 <code>key-value（关键字—值）</code> 对：关键字起到索引的作用，值则表示与索引相关联的数据；<code>set</code> 与之相对就是关键字的简单集合，<code>set</code> 中每个元素只包含一个关键字。</p></li><li><p>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p></li><li><p>map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符 <code>[]</code> 将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符 <code>[]</code> 在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果 <code>find</code> 能解决需要，尽可能用 <code>find</code>。</p></li></ol><h3 id="介绍一下-STL-的-allocator"><a href="#介绍一下-STL-的-allocator" class="headerlink" title="介绍一下 STL 的 allocator"></a>介绍一下 <code>STL</code> 的 <code>allocator</code></h3><p>STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：</p><p>new运算分两个阶段：</p><ol><li>调用 <code>::operator new</code> 配置内存；</li><li>调用对象构造函数构造对象内容。</li></ol><p>delete运算分两个阶段：</p><ol><li>调用对象析构函数；</li><li>调用 <code>::operator delete</code> 释放内存。</li></ol><p>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置由 <code>alloc::allocate()</code> 负责，内存释放由 <code>alloc::deallocate()</code> 负责；对象构造由 <code>::construct()</code> 负责，对象析构由 <code>::destroy()</code> 负责。</p><p>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过 <code>128B</code> 时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用 <code>malloc()</code>、<code>realloc()</code>、<code>free()</code> 函数进行内存空间的分配和释放，而第二级空间配置器采用了 <code>内存池</code> 技术，通过空闲链表来管理内存。</p><h3 id="说一说STL迭代器删除元素"><a href="#说一说STL迭代器删除元素" class="headerlink" title="说一说STL迭代器删除元素"></a>说一说STL迭代器删除元素</h3><p>这个主要考察的是迭代器失效的问题。</p><ol><li>对于序列容器 <code>vector</code>、<code>deque</code> 来说，使用 <code>erase(iterator)</code> 后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；</li><li>对于关联容器<code>map</code>、<code>set</code> 来说，使用了 <code>erase(iterator)</code> 后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；</li><li>对于 <code>list</code> 来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</li></ol><h3 id="STL中map数据存放形式"><a href="#STL中map数据存放形式" class="headerlink" title="STL中map数据存放形式"></a>STL中map数据存放形式</h3><p>红黑树。unordered_map底层结构是哈希表。</p><h3 id="讲讲STL有什么基本组成"><a href="#讲讲STL有什么基本组成" class="headerlink" title="讲讲STL有什么基本组成"></a>讲讲STL有什么基本组成</h3><p>STL主要由以下几部分组成：</p><ul><li>容器</li><li>迭代器</li><li>仿函数</li><li>算法</li><li>分配器</li><li>配接器</li></ul><p>他们之间的关系：<code>分配器</code> 给 <code>容器</code> 分配存储空间，<code>算法</code> 通过 <code>迭代器</code> 获取 <code>容器</code> 中的内容，<code>仿函数</code> 可以协助 <code>算法</code> 完成各种操作，<code>配接器</code> 用来套接适配 <code>仿函数</code>。</p><h3 id="说说STL中map与unordered-map"><a href="#说说STL中map与unordered-map" class="headerlink" title="说说STL中map与unordered_map"></a>说说STL中map与unordered_map</h3><ol><li><p><code>map映射</code></p><p> <code>map</code> 的所有元素都是 <code>pair</code>，同时拥有键值（<code>key</code>）和实值（<code>value</code>）。<code>pair</code> 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。<br> 底层实现：<code>红黑树</code></p><p> 适用场景：有序键值对 <code>不重复映射</code></p><ul><li>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。<br>红黑树，内部实现一个红黑书使得map的很多操作在 <code>logn</code> 的时间复杂度下就可以实现，因此效率非常的高。</li><li>缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</li><li>适用处：对于那些有顺序要求的问题，用map会更高效一些。</li></ul></li><li><p>unordered_map</p><ul><li>优点： 因为内部实现了哈希表，因此其查找速度非常的快。</li><li>缺点： 哈希表的建立比较耗费时间</li><li>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map。</li></ul><blockquote><p><strong>总结：</strong><br>内存占有率的问题就转化成红黑树 VS hash表，还是unorder_map占用的内存要高。<br>但是unordered_map执行效率要比map高很多<br>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的。<br><strong>map和unordered_map的使用：</strong><br>unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p></blockquote></li><li><p>multimap</p><p> 多重映射。<code>multimap</code> 的所有元素都是 <code>pair</code>，同时拥有键值（<code>key</code>）和实值（<code>value</code>）。<code>pair</code> 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p><p> 底层实现：<code>红黑树</code></p><p> 适用场景：有序键值对 <code>可重复映射</code>。</p></li></ol><h3 id="说一说-vector-和-list-的区别，应用，越详细越好"><a href="#说一说-vector-和-list-的区别，应用，越详细越好" class="headerlink" title="说一说 vector 和 list 的区别，应用，越详细越好"></a>说一说 <code>vector</code> 和 <code>list</code> 的区别，应用，越详细越好</h3><ol><li><p>概念</p><ol><li><p>vector</p><ul><li>连续存储的容器，动态数组，在堆上分配空间。</li><li>底层实现：数组</li><li>两倍容量增长：<code>vector</code> 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器；如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</li><li>性能：<ul><li>访问：O(1)</li><li>插入：在最后插入（空间够）：很快</li><li>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</li><li>在中间插入（空间够）：内存拷贝</li><li>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</li><li>在最后删除：很快</li><li>在中间删除：内存拷贝</li></ul></li><li>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</li></ul></li><li><p>list</p><ul><li>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</li><li>底层：双向链表</li><li>性能：<ul><li>访问：随机访问性能很差，只能快速访问头尾节点</li><li>插入：很快，一般是常数开销</li><li>删除：很快，一般是常数开销</li><li>适用场景：经常插入删除大量数据</li></ul></li></ul></li></ol></li><li><p>区别</p><ol><li>vector底层实现是数组，list是双向链表。</li><li>vector支持随机访问，list不支持。</li><li>vector是顺序内存，list不是。</li><li>vector在中间节点进行插入删除会导致内存拷贝，list不会。</li><li>vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</li><li>vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</li></ol></li><li><p>应用<br> vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p><p> list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p></li></ol><h3 id="说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="说一下STL中迭代器的作用，有指针为何还要迭代器"></a>说一下STL中迭代器的作用，有指针为何还要迭代器</h3><ol><li><p>迭代器<br> Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p><p> 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p></li><li><p>迭代器和指针的区别</p><ul><li><p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、—等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，—等操作。</p></li><li><p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p></li></ul></li><li><p>迭代器产生原因<br> Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p></li></ol><h3 id="说一说epoll原理"><a href="#说一说epoll原理" class="headerlink" title="说一说epoll原理"></a>说一说epoll原理</h3><p>调用顺序：</p><pre><code class="lang-C++">int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</code></pre><p>首先创建一个 <code>epoll</code> 对象，然后使用 <code>epoll_ctl</code> 对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以 <code>epoll_event</code> 结构体的形式组成一颗红黑树，接着阻塞在 <code>epoll_wait</code>，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。</p><h3 id="n-个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为-O-N"><a href="#n-个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为-O-N" class="headerlink" title="n 个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为 O(N)"></a><code>n</code> 个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为 <code>O(N)</code></h3><pre><code class="lang-C++">vector&lt;int&gt; findMax(vector&lt;int&gt; num){    if (num.size() == 0)    {        return num;    }    vector&lt;int&gt; res(num.size());    stack&lt;int&gt; s;    int i = 0;    while (i &lt; num.size())    {        if (s.empty() || num[s.top()] &gt;= num[i])        {            // 保存原数组下标            s.push(i++);        }        else        {            res[s.top()] = num[i];            s.pop();        }    }    while (!s.empty())    {        res[s.top()] = INT_MAX;        s.pop();    }    for (int n : res)    {        cout &lt;&lt; n &lt;&lt; endl;    }    return res;}</code></pre><h3 id="回答一下STL里-resize-和-reserve-的区别"><a href="#回答一下STL里-resize-和-reserve-的区别" class="headerlink" title="回答一下STL里 resize 和 reserve 的区别"></a>回答一下STL里 <code>resize</code> 和 <code>reserve</code> 的区别</h3><ul><li><p><code>resize()</code>：改变当前容器内含有元素的数量(size())，eg: <code>vector&lt;int&gt;v; v.resize(len);</code> v的size变为len，如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为 <code>0</code>。当 <code>v.push_back(3);</code> 之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</p></li><li><p><code>reserve()</code>：改变当前容器的最大容量（capacity），它不会生成元素，只是确定这个容器允许放入多少对象。<strong>如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存。</strong></p></li></ul><p><strong>测试代码：</strong></p><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    vector&lt;int&gt; a;    a.reserve(100);    a.resize(50);    cout &lt;&lt; a.size() &lt;&lt; &quot;  &quot; &lt;&lt; a.capacity() &lt;&lt; endl;    //50  100    a.resize(150);    cout &lt;&lt; a.size() &lt;&lt; &quot;  &quot; &lt;&lt; a.capacity() &lt;&lt; endl;    //150  150    a.reserve(50);    cout &lt;&lt; a.size() &lt;&lt; &quot;  &quot; &lt;&lt; a.capacity() &lt;&lt; endl;    //150  150    a.resize(50);    cout &lt;&lt; a.size() &lt;&lt; &quot;  &quot; &lt;&lt; a.capacity() &lt;&lt; endl;    //50  150}</code></pre><h2 id="类和数据抽象"><a href="#类和数据抽象" class="headerlink" title="类和数据抽象"></a>类和数据抽象</h2><h3 id="说一下C-中类成员的访问权限"><a href="#说一下C-中类成员的访问权限" class="headerlink" title="说一下C++中类成员的访问权限"></a>说一下C++中类成员的访问权限</h3><p>C++通过 <code>public</code>、<code>protected</code>、<code>private</code> 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 <code>public</code>、<code>protected</code> 还是 <code>private</code>，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 <code>public</code> 属性的成员，不能访问 <code>private</code>、<code>protected</code> 属性的成员。<br><strong>要注意的是，如果未注明访问权限关键字，默认为 <code>private</code></strong></p><h3 id="说一下C-中-struct-和-class-的区别"><a href="#说一下C-中-struct-和-class-的区别" class="headerlink" title="说一下C++中 struct 和 class 的区别"></a>说一下C++中 <code>struct</code> 和 <code>class</code> 的区别</h3><p>在C++中，可以用 <code>struct</code> 和class定义类，都可以继承。区别在于：struct的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。<br>另外，class还可以定义模板类形参，比如 <code>template &lt;class T, int i&gt;</code>。</p><h3 id="C-类内可以定义引用数据成员吗"><a href="#C-类内可以定义引用数据成员吗" class="headerlink" title="C++类内可以定义引用数据成员吗"></a>C++类内可以定义引用数据成员吗</h3><p>可以，必须通过成员函数初始化列表初始化。</p><pre><code class="lang-C++">class MyClass{public:    MyClass(int &amp;i) : a(1), b(i) //构造函数初始化列表中是初始化工作    {        //在这里做的是赋值而非初始化工作    }private:    const int a;    int &amp;b;};</code></pre><h2 id="面向对象与泛型编程"><a href="#面向对象与泛型编程" class="headerlink" title="面向对象与泛型编程"></a>面向对象与泛型编程</h2><h3 id="什么是右值引用，跟左值又有什么区别"><a href="#什么是右值引用，跟左值又有什么区别" class="headerlink" title="什么是右值引用，跟左值又有什么区别"></a>什么是右值引用，跟左值又有什么区别</h3><p>右值引用是C++11中引入的新特性，它实现了转移语义和精确传递。它的主要目的有两个方面：</p><ol><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ol><p>左值和右值的概念：</p><p><strong>左值：</strong> 能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。<br><strong>右值：</strong> 不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p><p>右值引用和左值引用的区别：</p><ol><li>左值可以寻址，而右值不可以。</li><li>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</li><li>左值可变，右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</li></ol><h2 id="编译与底层"><a href="#编译与底层" class="headerlink" title="编译与底层"></a>编译与底层</h2><h3 id="说一下一个C-源文件从文本到可执行文件经历的过程"><a href="#说一下一个C-源文件从文本到可执行文件经历的过程" class="headerlink" title="说一下一个C++源文件从文本到可执行文件经历的过程"></a>说一下一个C++源文件从文本到可执行文件经历的过程</h3><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p><ol><li><p><strong>预处理阶段：</strong> 对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件；</p></li><li><p><strong>编译阶段：</strong> 将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件；</p></li><li><p><strong>汇编阶段：</strong> 将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件；</p></li><li><p><strong>链接阶段：</strong> 将多个目标文件及所需要的库连接成最终的可执行目标文件。</p></li></ol><h3 id="include头文件的顺序以及双引号-quot-quot-和尖括号-lt-gt-的区别"><a href="#include头文件的顺序以及双引号-quot-quot-和尖括号-lt-gt-的区别" class="headerlink" title="include头文件的顺序以及双引号 &quot;&quot; 和尖括号 &lt;&gt; 的区别"></a>include头文件的顺序以及双引号 <code>&quot;&quot;</code> 和尖括号 <code>&lt;&gt;</code> 的区别</h3><p>include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h，那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h，否则汇报变量类型未声明错误。</p><p>双引号和尖括号的区别：<strong>编译器预处理阶段查找头文件的路径不一样</strong>。</p><blockquote><p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p><ol><li>当前头文件目录</li><li>编译器设置的头文件路径（编译器可使用 <code>-I</code> 显式指定搜索路径）</li><li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li></ol><p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p><ol><li>编译器设置的头文件路径（编译器可使用 <code>-I</code> 显式指定搜索路径）</li><li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径。</li></ol></blockquote><h3 id="回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么"><a href="#回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么" class="headerlink" title="回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么"></a>回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么</h3><p><code>malloc</code> 函数用于 <strong>动态分配内存</strong>。为了减少内存碎片和系统调用的开销，<code>malloc</code> 其采用 <code>内存池</code> 的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。<code>malloc</code> 采用 <code>隐式链表结构</code> 将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时 <code>malloc</code> 采用显示链表结构来管理所有的空闲块，即使用一个 <code>双向链表</code> 将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。<br>当进行内存分配时，<code>malloc</code> 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，<code>malloc</code> 采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p><p><code>malloc</code> 在申请内存时，一般会通过 <code>brk</code> 或者 <code>mmap</code> 系统调用进行申请。其中当申请内存 <code>小于128K</code> 时，会使用系统函数 <code>brk</code> 在 <code>堆区</code> 中分配；而当申请内存 <code>大于128K</code> 时，会使用系统函数 <code>mmap</code> 在 <code>映射区</code> 分配。</p><h3 id="说一说C-的内存管理是怎样的"><a href="#说一说C-的内存管理是怎样的" class="headerlink" title="说一说C++的内存管理是怎样的"></a>说一说C++的内存管理是怎样的</h3><p>在C++中，虚拟内存分为 <code>代码段</code>、<code>数据段</code>、<code>BSS段</code>、<code>堆区</code>、<code>文件映射区</code>以及 <code>栈区</code> 六部分。</p><ul><li><p><code>代码段</code>：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码；</p></li><li><p><code>数据段</code>：存储程序中已初始化的全局变量和静态变量；</p></li><li><p><code>BSS段</code>：存储未初始化的全局变量和静态变量（局部 + 全局），以及所有被初始化为 <code>0</code> 的全局变量和静态变量；</p></li><li><p><code>堆区</code>：调用 <code>new/malloc</code> 函数时在堆区动态分配内存，同时需要调用 <code>delete/free</code> 来手动释放申请的内存；</p></li><li><p><code>映射区</code>：存储动态链接库以及调用 <code>mmap</code> 函数进行的文件映射</p></li><li><p><code>栈</code>：使用栈空间存储函数的 <strong>返回地址、参数、局部变量、返回值</strong>。</p></li></ul><h3 id="C-C的内存分配"><a href="#C-C的内存分配" class="headerlink" title="C++/C的内存分配"></a>C++/C的内存分配</h3><p>32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p><p><img src="/2020/03/21/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++内存分配.png" srcset="/img/loading.gif" alt="C++/C内存分配"></p><p>各个段说明如下：</p><p>3G用户空间和1G内核空间</p><p><strong>静态区域：</strong></p><ul><li><p><code>text segment（代码段）</code>：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p></li><li><p><code>data segment（数据段）</code>：存储程序中已初始化的全局变量和静态变量</p></li><li><p><code>bss segment</code>：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p></li></ul><p><strong>动态区域：</strong></p><p><code>heap（堆）</code>： 当进程未调用malloc时是没有堆段的，只有调用 <code>malloc</code> 时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小（移动break指针），从低地址向高地址增长。分配小内存时使用该区域。堆的起始地址由 <code>mm_struct</code> 结构体中的 <code>start_brk</code> 标识，结束地址由 <code>brk</code> 标识。</p><p><code>memory mapping segment（映射区）</code>：存储动态链接库等文件映射、申请大内存（<code>malloc</code> 时调用 <code>mmap</code> 函数）</p><p><code>stack（栈）</code>：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过 <code>ulimit</code> 命令指定。</p><h3 id="如何判断内存泄漏"><a href="#如何判断内存泄漏" class="headerlink" title="如何判断内存泄漏"></a>如何判断内存泄漏</h3><p>内存泄漏通常是由于调用了 <code>malloc/new</code> 等内存申请的操作，但是缺少了对应的 <code>free/delete</code>。为了判断内存是否泄露，我们一方面可以<strong>使用Linux环境下的内存泄漏检查工具 <code>Valgrind</code></strong>，另一方面我们在写代码时可以<strong>添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致</strong>，以此来判断内存是否泄露。</p><h3 id="什么时候会发生段错误"><a href="#什么时候会发生段错误" class="headerlink" title="什么时候会发生段错误"></a>什么时候会发生段错误</h3><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p><ul><li>使用野指针</li><li>试图修改字符串常量的内容</li></ul><h3 id="什么是memory-leak，也就是内存泄漏"><a href="#什么是memory-leak，也就是内存泄漏" class="headerlink" title="什么是memory leak，也就是内存泄漏"></a>什么是memory leak，也就是内存泄漏</h3><p><code>内存泄漏（memory leak）</code>是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><p>内存泄漏的<strong>分类</strong>：</p><ol><li><p><code>堆内存泄漏（Heap leak）</code>。对内存指的是程序运行中根据需要分配通过 <code>malloc</code>、<code>realloc</code>、<code>new</code> 等从堆中分配的一块内存，再是完成后必须通过调用对应的 <code>free</code> 或者 <code>delete</code> 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p></li><li><p><code>系统资源泄露（Resource Leak）</code>。主要指程序使用系统分配的资源比如 <code>Bitmap</code>、<code>handle</code>、<code>SOCKET</code> 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p></li><li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p></li></ol><h3 id="回答一下new和malloc的区别"><a href="#回答一下new和malloc的区别" class="headerlink" title="回答一下new和malloc的区别"></a>回答一下new和malloc的区别</h3><ol><li><code>new</code> 分配内存按照数据类型进行分配，<code>malloc</code> 分配内存按照指定的大小分配；</li><li><code>new</code> 返回的是指定对象的指针，而 <code>malloc</code> 返回的是 <code>void*</code>，因此 <code>malloc</code> 的返回值一般都需要进行类型转化；</li><li><strong><code>new</code> 不仅分配一段内存，而且会调用构造函数，<code>malloc</code> 不会；</strong></li><li><code>new</code> 分配的内存要用 <code>delete</code> 销毁，<code>malloc</code> 要用 <code>free</code> 来销毁；<code>delete</code> 销毁的时候会调用对象的析构函数，而 <code>free</code> 则不会；</li><li><code>new</code> 是一个操作符可以重载，<code>malloc</code> 是一个库函数；</li><li><code>malloc</code> 分配的内存不够的时候，可以用 <code>realloc</code> 扩容；<code>new</code> 没用这样操作。<blockquote><p><strong><code>realloc</code>扩容的原理？</strong><br>对于这样的操作：</p><pre><code class="lang-C">char* p = malloc(1024);char* q = realloc(p, 2048);</code></pre><ol><li>如果当前连续内存块足够 <code>realloc</code> 的话，只是将 <code>p</code> 所指向的空间扩大，并返回 <code>p</code> 的指针地址。这个时候 <code>q</code> 和 <code>p</code> 指向的地址是一样的。</li><li>如果当前连续内存块不够长度，再找一个足够长的地方，分配一块新的内存 <code>q</code>，并将 <code>p</code> 指向的内容copy到 <code>q</code>，返回 <code>q</code>。并将 <code>p</code> 所指向的内存空间删除。</li></ol><p>这样也就是说 <code>realloc</code> 有时候会产生一个新的内存地址，有的时候不会。所以在分配完成后。我们需要判断下 <code>p</code> 是否等于 <code>q</code>，并做相应的处理。</p></blockquote></li><li><code>new</code> 如果分配失败了会抛出 <code>bad_malloc</code> 的异常，而 <code>malloc</code> 失败了会返回 <code>NULL</code>。</li><li>申请数组时 <code>new[]</code> 一次分配所有内存，多次调用构造函数，搭配使用 <code>delete[]</code>，<code>delete[]</code> 多次调用析构函数，销毁数组中的每个对象；而 <code>malloc</code> 则只能 <code>sizeof(int) * n</code>。</li></ol><h3 id="共享内存相关API"><a href="#共享内存相关API" class="headerlink" title="共享内存相关API"></a>共享内存相关API</h3><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在 <code>sys/shm.h</code> 中。</p><ol><li><p>新建共享内存 <code>shmget</code></p><pre><code class="lang-C"> int shmget(key_t key, size_t size, int shmflg);</code></pre><p> <code>key</code>：共享内存键值，可以理解为共享内存的唯一性标记。<br> <code>size</code>：共享内存大小。<br> <code>shmflag</code>：创建进程和其他进程的读写权限标识。<br> <code>返回值</code>：相应的共享内存标识符，失败返回 <code>-1</code>。</p></li><li><p>连接共享内存到当前进程的地址空间 <code>shmat</code></p><pre><code class="lang-C"> void *shmat(int shm_id, const void *shm_addr, int shmflg);</code></pre><p> <code>shm_id</code>：共享内存标识符。<br> <code>shm_addr</code>：指定共享内存连接到当前进程的地址，通常为 <code>0</code>，表示由系统来选择。<br> <code>shmflg</code>：标志位。<br> <code>返回值</code>：指向共享内存第一个字节的指针，失败返回 <code>-1</code>。</p></li><li><p>当前进程分离共享内存 <code>shmdt</code></p><pre><code class="lang-C"> int shmdt(const void *shmaddr);</code></pre></li><li><p>控制共享内存 <code>shmctl</code></p><p> 和信号量的semctl函数类似，控制共享内存。</p><pre><code class="lang-C"> int shmctl(int shm_id, int command, struct shmid_ds *buf);</code></pre><p> <code>shm_id</code>：共享内存标识符。<br> <code>command</code>：有三个值。<br> <code>IPC_STAT</code>：获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。<br> <code>IPC_SET</code>：设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。<br> <code>IPC_RMID</code>：删除共享内存。<br> <code>buf</code>：共享内存管理结构体。</p></li></ol><h3 id="设计一下如何采用单线程的方式处理高并发"><a href="#设计一下如何采用单线程的方式处理高并发" class="headerlink" title="设计一下如何采用单线程的方式处理高并发"></a>设计一下如何采用单线程的方式处理高并发</h3><p>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件。</p><h3 id="说一说C-STL-的内存优化"><a href="#说一说C-STL-的内存优化" class="headerlink" title="说一说C++ STL 的内存优化"></a>说一说C++ STL 的内存优化</h3><ol><li>二级配置器结构<br> STL内存管理使用二级内存配置器。<ol><li>第一级配置器（分配大区块）<br> 第一级配置器以 <code>malloc()</code>，<code>free()</code>，<code>realloc()</code> 等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br> 一级空间配置器分配的是大于128字节的空间，如果分配不成功，调用句柄释放一部分内存；如果还不能分配成功，抛出异常。</li><li>第二级配置器（避免小区块）<br> 在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</li><li>分配原则<br> 如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br> 如果要分配的区块小于128bytes，则以 <code>内存池管理（memory pool）</code>，又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br> 当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表；<br> 如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块；<br> 如果内存池空间足够，则取出内存；<br> 如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数；<br> 如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器。</li></ol></li><li>二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</li></ol><p><img src="/2020/03/21/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/二级内存池.png" srcset="/img/loading.gif" alt="二级内存池"></p><ol><li>空间配置函数 <code>allocate</code><br> 首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。</li><li>空间释放函数 <code>deallocate</code><br> 首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。</li><li>重新填充空闲链表 <code>refill</code><br> 在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br> 从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br> 假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。</li><li>总结：</li></ol><ul><li>1.使用 <code>allocate</code> 向 <code>内存池</code> 请求 <code>size</code> 大小的内存空间，如果需要请求的内存大小 <code>大于128bytes</code>，直接使用 <code>malloc</code>。</li><li>2.如果需要的内存大小 <code>小于128bytes</code>，<code>allocate</code> 根据 <code>size</code> 找到最适合的自由链表。<ul><li>a. 如果链表不为空，返回第一个node，链表头改为第二个node。</li><li>b. 如果链表为空，使用 <code>blockAlloc</code> 请求分配node。<ul><li>x. 如果内存池中有大于一个node的空间，分配尽可能多的node（但是最多20个），将一个node返回，其他的node添加到链表中。</li><li>y. 如果内存池只有一个node的空间，直接返回给用户。</li><li>z. 如果连一个node都没有，再次向操作系统请求分配内存。<ul><li>①分配成功，再次进行b过程。</li><li>②分配失败，循环各个自由链表，寻找空间。<ul><li>I. 找到空间，再次进行过程b。</li><li>II. 找不到空间，抛出异常。</li></ul></li></ul></li></ul></li></ul></li><li>3.用户调用 <code>deallocate</code> 释放内存空间，如果要求释放的内存空间 <code>大于128bytes</code>，直接调用 <code>free</code>。</li><li>4.否则按照其大小找到合适的自由链表，并将其插入。</li></ul><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="C-11有哪些新特性"><a href="#C-11有哪些新特性" class="headerlink" title="C++11有哪些新特性"></a>C++11有哪些新特性</h3><p>C++11最常用的新特性如下：</p><ul><li><strong><code>auto</code> 关键字：</strong> 编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导。</li><li><strong><code>nullptr</code> 关键字：</strong> <code>nullptr</code> 是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而 <code>NULL</code> 一般被宏定义为 <code>0</code>，在遇到重载时可能会出现问题。</li><li><strong>智能指针：</strong> C++11新增了 <code>std::shared_ptr</code>、<code>std::weak_ptr</code> 等类型的智能指针，用于解决内存管理的问题。</li><li><strong>初始化列表：</strong> 使用初始化列表来对类进行初始化。</li><li><strong>右值引用：</strong> 基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li><strong><code>atomic</code> 原子操作</strong> 用于多线程资源互斥操作。</li><li>新增STL容器 <code>array</code> 以及 <code>tuple</code>。</li></ul><h3 id="详细介绍一下C-11中的可变参数模板、右值引用和-lambda-这几个新特性"><a href="#详细介绍一下C-11中的可变参数模板、右值引用和-lambda-这几个新特性" class="headerlink" title="详细介绍一下C++11中的可变参数模板、右值引用和 lambda 这几个新特性"></a>详细介绍一下C++11中的可变参数模板、右值引用和 <code>lambda</code> 这几个新特性</h3><ul><li><p><strong>可变参数模板：</strong><br>  C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在 <code>class</code> 或 <code>typename</code> 后面带上省略号。</p><p>  例如：</p><pre><code class="lang-C++">  #include &lt;iostream&gt;  using namespace std;  template &lt;class... T&gt;  void func(T... args)  {      cout &lt;&lt; &quot;num is &quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;  }  int main()  {      func();       //args不含任何参数      func(1);      //args包含一个int类型的实参      func(1, 2.0); //args包含一个int一个double类型的实参      return 0;  }</code></pre><p>  其中 <code>T</code> 叫做模板参数包，<code>args</code> 叫做函数参数包。</p><p>  输出结果如下：</p><pre><code class="lang-C++">  num is 0  num is 1  num is 2</code></pre><p>  省略号作用如下：</p><ol><li>声明一个包含0到任意个模板参数的参数包；</li><li><p>在模板定义得右边，可以将参数包展成一个个独立的参数。</p><p>C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。</p><p>例如：</p><pre><code class="lang-C++">#include &lt;iostream&gt;using namespace std;// 最终递归函数void print(){ cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;}// 展开函数template &lt;class T, class... Args&gt;void print(T head, Args... args){ cout &lt;&lt; head &lt;&lt; &quot;, &quot;; print(args...);}int main(){ print(1, 2, 3, 4); return 0;}</code></pre><p>输出结果如下：</p><pre><code class="lang-C++">1, 2, 3, 4, empty</code></pre></li></ol></li><li><p><strong>右值引用：</strong></p><p>  C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如 <code>1+3</code> 产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用 <code>T&amp;&amp;</code> 的函数返回值等。</p><p>  C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：</p><pre><code class="lang-C++">  T &amp;&amp; a = ReturnRvale();</code></pre><p>  假设 <code>ReturnRvalue()</code> 函数返回一个右值，那么上述语句声明了一个名为 <code>a</code> 的右值引用，其值等于 <code>ReturnRvalue()</code> 函数返回的临时变量的值。</p><p>  基于右值引用可以实现转移语义和完美转发新特性。</p></li><li><p><strong>移动语义：</strong></p><p>  对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。</p><p>  但是如下列代码所示：</p><pre><code class="lang-C++">  #include &lt;iostream&gt;  using namespace std;  class HasPtrMem  {  public:      HasPtrMem() : d(new int(0))      {          cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; ++n_cstr &lt;&lt; endl;      }      HasPtrMem(const HasPtrMem &amp;h) : d(new int(*h.d))      {          cout &lt;&lt; &quot;Copy construct: &quot; &lt;&lt; ++n_cptr &lt;&lt; endl;      }      ~HasPtrMem()      {          cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; ++n_dstr &lt;&lt; endl;      }      int *d;      static int n_cstr;      static int n_dstr;      static int n_cptr;  };  int HasPtrMem::n_cstr = 0;  int HasPtrMem::n_dstr = 0;  int HasPtrMem::n_cptr = 0;  HasPtrMem GetTemp() { return HasPtrMem(); }  int main()  {      HasPtrMem a = GetTemp();      return 0;  }</code></pre><p>  当类 <code>HasPtrMem</code> 包含一个成员函数 <code>GetTemp</code>，其返回值类型是 <code>HasPtrMem</code>，如果我们定义了深拷贝的拷贝构造函数，那么在调用该函数时需要调用两次拷贝构造函数。第一次是<strong>生成GetTemp函数返回时的临时变量</strong>，第二次是<strong>将该返回值赋值给main函数中的变量a</strong>。与此对应需要调用三次析构函数来释放内存。</p><p>  而在上述过程中，使用临时变量构造a时会调用拷贝构造函数分配对内存，而临时对象在语句结束后会释放它所使用的堆内存。这样重复申请和释放内存，在申请内存较大时会严重影响性能。因此C++使用移动构造函数，从而保证使用临时对象构造a时不分配内存，从而提高性能。</p><p>  如下列代码所示，移动构造函数接收一个右值引用作为参数，使用右值引用的参数初始化其指针成员变量。</p><pre><code class="lang-C++">  HasPtrMem(HasPtrMem &amp;&amp;h) : d(h.d)  {      h.d = nullptr;      cout &lt;&lt; &quot;Move construct: &quot; &lt;&lt; ++n_mvtr &lt;&lt; endl;  }</code></pre><p>  其原理就是使用在构造对象a时，使用 <code>h.d</code> 来初始化a，然后将临时对象h的成员变量d指向 <code>nullptr</code>，从而保证临时变量析构时不会释放对内存。</p><p>  <img src="/2020/03/21/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/右值引用构造.png" srcset="/img/loading.gif" alt="右值引用构造"></p></li><li><p><strong>完美转发：</strong></p><p>  完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销。</p><p>  因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型。</p></li><li><p><strong>Lambda表达式：</strong></p><p>  Lambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量，其定义如下：</p><pre><code class="lang-C++">  [capture](params)mutable-&gt;return-type{statement}</code></pre><p>  其中，</p><ul><li><strong>[capture]：</strong> 捕获列表，捕获上下文变量以供lambda使用。同时 <code>[]</code> 是lambda运算符，编译器根据该符号来判断接下来代码是否是lambda函数。</li><li><strong>(Params)：</strong> 参数列表，与普通函数的参数列表一致，如果不需要传递参数，则可以连通括号一起省略。</li><li><strong><code>mutable</code></strong> 是修饰符，默认情况下lambda函数总是一个 <code>const</code> 函数，<code>mutable</code>可以取消其常量性。在使用该修饰符时，参数列表不可省略。</li><li><strong>-&gt;return-type：</strong> 返回类型是返回值类型。</li><li><p><strong>{statement}：</strong> 函数体，内容与普通函数一样，除了可以使用参数之外，还可以使用所捕获的变量。</p><pre><code class="lang-C++">[](int x, int y) { return x + y; }  // 隐式返回类型[](int &amp;x) { ++x; }                 // 没有 return 语句 -&gt; Lambda 函数的返回类型是void[]() { ++global_x; }                // 没有参数，仅访问某个全局变量[] { ++global_x; }                  // 与上一个相同，省略了 (操作符重载函数参数)</code></pre><p>Lambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。其形式如下:</p></li><li><p><code>[var]</code> 表示值传递方式捕捉变量var。</p></li><li><code>[=]</code> 表示值传递方式捕捉所有父作用域的变量（包括this）。</li><li><code>[&amp;var]</code> 表示引用传递捕捉变量var。</li><li><code>[&amp;]</code> 表示引用捕捉所有父作用域的变量（包括this）。</li><li><p><code>[this]</code> 表示值传递方式捕捉当前的this指针。</p><p><strong>示例1：</strong><br><code>0 ~ 4</code>的累加和，结果为 <code>10</code>。</p><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){    vector&lt;int&gt; some_list;    int total = 0;    for (int i = 0; i &lt; 5; ++i)        some_list.push_back(i);    for_each(begin(some_list), end(some_list), [&amp;total](int x) {        total += x;    });    cout &lt;&lt; total &lt;&lt; endl;    return 0;}</code></pre><p><strong>示例2：</strong><br>类内<code>0 ~ 4</code>的累加和，结果为 <code>10</code>。</p><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Test{public:    void test()    {        vector&lt;int&gt; some_list;        int total = 0;        int value = 1;        for (int i = 0; i &lt; 5; ++i)            some_list.push_back(i);        for_each(begin(some_list), end(some_list), [&amp;, value, this](int x) {            total += x * value * this-&gt;some_func();        });        cout &lt;&lt; total &lt;&lt; endl;    }    int some_func()    {        return 1;    }};int main(){    Test().test();    return 0;}</code></pre><p>Lambda的类型被定义为“闭包”的类，其通常用于STL库中，在某些场景下可用于简化仿函数的使用，同时Lambda作为局部函数，也会提高复杂代码的开发加速，轻松在函数内重用代码，无须费心设计接口。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>面经知识汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯校内模拟赛复盘</title>
    <link href="/2020/03/18/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    <url>/2020/03/18/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2020年3月15日蓝桥杯校内模拟赛，难度较为简单。</p></blockquote><a id="more"></a><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><p>本人报的是 <code>C/C++</code> 类型的比赛，在填空题时为了快速得出结果采用的是 <code>Python</code>。</p><h3 id="1-1200000-有多少个约数？（只计算正约数）"><a href="#1-1200000-有多少个约数？（只计算正约数）" class="headerlink" title="1. 1200000 有多少个约数？（只计算正约数）"></a>1. <code>1200000</code> 有多少个约数？（只计算正约数）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题从 $[1, 1200000]$ 遍历即可，结果为 <code>96</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><p>Python</p><ul><li>法1（常规做法）</li></ul><pre><code class="lang-Python">res = 0for i in range(1, 1200001):    if 1200000 % i == 0:        res += 1print(res)</code></pre><ul><li>法2（列表生成式）</li></ul><pre><code class="lang-Python">print(sum([1200000 % i == 0 for i in range(1, 1200001)]))</code></pre></li><li><p>C++</p><pre><code class="lang-C++">#include &lt;iostream&gt;using namespace std;int main(){    int res = 0;    for (int i = 1; i &lt;= 1200000; i++)    {        if (1200000 % i == 0)        {            res++;        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre></li></ul><h3 id="2-在计算机存储中，15-125GB是多少MB"><a href="#2-在计算机存储中，15-125GB是多少MB" class="headerlink" title="2. 在计算机存储中，15.125GB是多少MB"></a>2. 在计算机存储中，15.125GB是多少MB</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>根据进制换算 $1GB = 2 ^ {10} MB = 1024MB$，进行简单乘法 $15.125 * 1024 = 15488$。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-C++">#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; (15.125 * 1024) &lt;&lt; endl;    return 0;}</code></pre><h3 id="3-一棵包含有-2019-个结点的树，最多包含多少个叶结点"><a href="#3-一棵包含有-2019-个结点的树，最多包含多少个叶结点" class="headerlink" title="3. 一棵包含有 2019 个结点的树，最多包含多少个叶结点"></a>3. 一棵包含有 <code>2019</code> 个结点的树，最多包含多少个叶结点</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在总结点数一定时，完全二叉树中有最多的叶子结点。<br>我在做题时忘了具体的计算公式，是在纸上画图算的，思路是算出每一层的二叉树结点数：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第几层</th><th style="text-align:center">结点数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">512</td></tr></tbody></table></div><p>可看出当层数为 $n$ 时每一层的结点数为 $2 ^ {n -1}$，那么前 $n$ 层的结点总数为 $1 + 2 + 3 + … + 2 ^ {n - 1} = 2 ^ n - 1$，采取快速逼近的思想，要使结点总数最接近 <code>2019</code>，当 $n = 10$ 时结点总数为 <code>1023</code>，与 <code>2019</code> 相差 <code>996</code>，故最后一层有 <code>996</code> 个结点，占用了倒数第2层 <code>498</code> 个结点的子结点位置，使得倒数第2层减少了 <code>498</code> 个叶子结点（倒数第2层总共有 <code>512</code> 个结点）而剩下 <code>14</code> 个叶子结点。所以叶子结点总共有 最后一层 <code>996</code> + 倒数第2层 <code>14</code> = <code>1010</code> 个结点。</p><hr><p>后来看到有<a href="https://blog.csdn.net/weixin_42449444/article/details/104823371" target="_blank" rel="noopener">大佬的博客</a>提到由结点总数推出叶子结点数的公式。</p><blockquote><p>太长不看版<br>叶子结点最多的个数与结点总数的奇偶有关，奇数个则有 $\frac{n + 1}{2}$个，偶数个则有 $\frac{n}{2}$ 个。</p></blockquote><p><strong>具体分析：</strong></p><p>叶子结点就是出度为 <code>0</code> 的结点，即没有子结点的结点。</p><ol><li><p>假设 $n$ 为完全二叉树的结点总数，$n_0$ 是度为0的结点总数（即叶子结点数），$n_1$ 是度为1的结点总数，$n_2$ 是度为2的结点总数，边数为b。</p></li><li><p>由<a href="https://blog.csdn.net/TinnCHEN/article/details/84023083" target="_blank" rel="noopener">二叉树的性质</a>可知：<script type="math/tex">n = n_0 + n_1 + n_2\tag{1}</script> <script type="math/tex">b = n - 1(二叉树是最小连通图)\tag{2}</script><br>联立两式得<script type="math/tex">b = n_0 + n_1 + n_2 - 1</script><br>另有 <script type="math/tex">b = n_1 + 2n_2</script><br>则有 <script type="math/tex">n_0 + n_1 + n_2 - 1 = n_1 + 2n_2</script><br>即 <script type="math/tex">n_2 = n_0 - 1\tag{3}</script></p></li><li><p>将上述 <code>(1)</code> <code>(3)</code> 把 $n_2$ 消去可得：<script type="math/tex">n = 2n_0 + n_1 - 1</script></p></li><li><p>由于完全二叉树中度为1的结点数 $n_1$ 只有两种可能 <code>0</code> 或 <code>1</code>：<br>当 $n_1 = 0$ 时 <script type="math/tex">n_0 = \frac{n + 1}{2}\tag{4}</script><br>当 $n_1 = 1$ 时 <script type="math/tex">n_0 = \frac{n}{2}\tag{5}</script></p></li><li><p>完全二叉树中除去最后一层的结点总数有 $(2 ^ n - 1)$ 个，为奇数，根据完全二叉树的结点总数 $n = 2019$ 可以知道最后一层结点数为偶数（奇数 - 奇数 = 偶数），故度为1的结点数 $n_1 = 0$，利用公式 <code>(4)</code> 求出叶子结点数 $n_0 = \frac{n + 1}{2} = \frac{2019 + 1}{2}= 1010$。</p></li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-C++">#include &lt;iostream&gt;using namespace std;int main(){    int n = 2019;    if (n % 2 == 1) //若结点总数为奇数，则n1 = 0    {        cout &lt;&lt; (n + 1) / 2 &lt;&lt; endl;    }    else //若结点总数为偶数，则n1 = 1    {        cout &lt;&lt; n / 2 &lt;&lt; endl;    }    return 0;}</code></pre><h3 id="4-在-1-至-2019-中，有多少个数的数位中包含数字-9"><a href="#4-在-1-至-2019-中，有多少个数的数位中包含数字-9" class="headerlink" title="4. 在 1 至 2019 中，有多少个数的数位中包含数字 9"></a>4. 在 <code>1</code> 至 <code>2019</code> 中，有多少个数的数位中包含数字 <code>9</code></h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>本题从 $[1, 2019]$ 遍历即可，结果为 <code>544</code>。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul><li><p>Python</p><ul><li>法1（常规做法）</li></ul><pre><code class="lang-Python">res = 0for num in range(1, 2020):    # 在循环体内修改循环变量不会影响循环条件中的循环变量    while num != 0:        if num % 10 == 9:            res += 1            break        else:            num //= 10print(res)</code></pre><ul><li>法2（列表生成式）</li></ul><pre><code class="lang-Python">print(sum([&#39;9&#39; in str(num) for num in range(1, 2020)]))</code></pre></li><li><p>C++</p></li></ul><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){    int res = 0;    for (int num = 1; num &lt;= 2019; num++)    {        string s = to_string(num);        if (s.find(&#39;9&#39;) != -1)        {            res++;        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="5-给定一个数列，请问数列中有多少个元素可能是递增三元组的中心"><a href="#5-给定一个数列，请问数列中有多少个元素可能是递增三元组的中心" class="headerlink" title="5. 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心"></a>5. 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心</h3><blockquote><p><strong>问题描述：</strong> 在数列 $a[1], a[2], …, a[n]$ 中，如果对于下标 $i, j, k$ 满足 $0 &lt; i &lt; j &lt; k &lt; n + 1$ 且 $a[i] &lt; a[j] &lt; a[k]$，则称 $a[i], a[j], a[k]$ 为一组递增三元组，$a[j]$ 为递增三元组的中心。</p></blockquote><p><strong>输入格式：</strong> 输入的第一行包含一个整数 <code>n</code>。第二行包含 <code>n</code> 个整数 <code>a[1]</code>, <code>a[2]</code>, …, <code>a[n]</code>，相邻的整数间用空格分隔，表示给定的数列。<br><strong>输出格式：</strong> 输出一行包含一个整数，表示答案。</p><blockquote><p><strong>样例输入：</strong><br>5<br>1 2 5 3 5<br><strong>样例输出：</strong><br>2<br><strong>样例说明：</strong> <code>a[2]</code> 和 <code>a[4]</code> 可能是三元组的中心。</p></blockquote><p><strong>评测用例规模与约定：</strong> 对于 <code>50%</code> 的评测用例，<code>2 &lt;= n &lt;= 100</code>，<code>0 &lt;= 数列中的数 &lt;= 1000</code>。对于 <code>所有</code> 评测用例，<code>2 &lt;= n &lt;= 1000</code>，<code>0 &lt;= 数列中的数 &lt;= 10000</code>。</p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>三层循环暴力遍历，时间复杂度为 $O(n ^ 3)$，在实际评测时可能会超时。</p><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){    int n;    cin &gt;&gt; n;    int a[n];    for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; a[i];    }    set&lt;int&gt; s;    for (int i = 0; i &lt; n - 2; i++)    {        for (int j = i + 1; j &lt; n - 1; j++)        {            for (int k = j + 1; k &lt; n; k++)            {                if (a[i] &lt; a[j] &amp;&amp; a[j] &lt; a[k])                {                    /* 注意，对于[1, 2, 2, 3]之类有重复连续元素的特殊数组                    此处如果是s.insert(a[j])，则结果会偏小 */                    s.insert(j);                    break; // 提前结束内层循环，节省时间                }            }        }    }    cout &lt;&lt; s.size() &lt;&lt; endl;    return 0;}</code></pre><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>正序遍历一次数组，<code>max</code> 数组记录满足 <code>a[i] &lt; a[j](i &lt; j)</code> 的下标元素 <code>j</code>；逆序遍历一次数组，<code>min</code> 数组记录满足 <code>a[j] &lt; a[k](j &lt; k)</code> 的下标元素 <code>j</code>，最后求 <code>max</code> 数组和 <code>min</code> 数组的交集数目。时间复杂度为 $O(n)$。</p><pre><code class="lang-C++">#include &lt;iostream&gt;using namespace std;int main(){    int n;    cin &gt;&gt; n;    int a[n];    bool max[n] = {false}, min[n] = {false};    for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; a[i];    }    int bottom = a[0];    for (int i = 1; i &lt; n - 1; i++)    {        if (a[i] &gt; bottom)        {            max[i] = true;        }        else if (a[i] &lt; bottom)        {            bottom = a[i];        }    }    int top = a[n - 1];    int res = 0;    for (int i = n - 2; i &gt;= 1; i--)    {        if (a[i] &lt; top)        {            min[i] = true;        }        else if (a[i] &gt; top)        {            top = a[i];        }    }    for (int i = 1; i &lt; n - 1; i++)    {        if (max[i] &amp;&amp; min[i])        {            res++;        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><p>而在逆序遍历时其实已经可以直接进行比较，去掉 <code>min</code> 数组以及省去最后一次遍历过程，节省时间。</p><pre><code class="lang-C++">#include &lt;iostream&gt;using namespace std;int main(){    int n;    cin &gt;&gt; n;    int a[n];    bool max[n] = {false};    for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; a[i];    }    int bottom = a[0];    for (int i = 1; i &lt; n - 1; i++)    {        if (a[i] &gt; bottom)        {            max[i] = true;        }        else if (a[i] &lt; bottom)        {            bottom = a[i];        }    }    int top = a[n - 1];    int res = 0;    for (int i = n - 2; i &gt;= 1; i--)    {        if (a[i] &lt; top &amp;&amp; max[i])        {            res++;        }        else if (a[i] &gt; top)        {            top = a[i];        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h3 id="6-给定正整数-n，请问在整数-1-至-n-中有多少个数位递增的数"><a href="#6-给定正整数-n，请问在整数-1-至-n-中有多少个数位递增的数" class="headerlink" title="6. 给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数"></a>6. 给定正整数 <code>n</code>，请问在整数 <code>1</code> 至 <code>n</code> 中有多少个数位递增的数</h3><blockquote><p><strong>问题描述：</strong> 一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。</p></blockquote><p><strong>输入格式：</strong> 输入的第一行包含一个整数 n。<br><strong>输出格式：</strong> 输出一行包含一个整数，表示答案。</p><blockquote><p><strong>样例输入：</strong> 30<br><strong>样例输出：</strong> 26</p></blockquote><p><strong>评测用例规模与约定：</strong> 对于 <code>40%</code> 的评测用例，<code>1 &lt;= n &lt;= 1000</code>。对于 <code>80%</code> 的评测用例，<code>1 &lt;= n &lt;= 100000</code>。对于 <code>所有</code> 评测用例，<code>1 &lt;= n &lt;= 1000000</code>。</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>本题从 $[1, n]$ 遍历即可。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-C++">#include &lt;iostream&gt;using namespace std;int main(){    int n;    cin &gt;&gt; n;    int res = 0;    for (int i = 1; i &lt;= n; i++)    {        int tmp = i, max = 9;        while (tmp)        {            if (tmp % 10 &lt;= max)            {                max = tmp % 10;            }            else            {                break;            }            tmp /= 10;        }        // 当tmp归零时说明该数已完全遍历        if (tmp == 0)        {            res++;        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h3 id="7-特殊单词"><a href="#7-特殊单词" class="headerlink" title="7. 特殊单词"></a>7. 特殊单词</h3><p><strong>问题描述：</strong> 小明对类似于 <code>hello</code> 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。给定一个单词，请判断这个单词是否也是这种单词，如果是请输出 <code>yes</code>，否则请输出 <code>no</code>。（元音字母包括 <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>，共五个，其他均为辅音字母。）</p><p><strong>输入格式：</strong> 输入一行，包含一个单词，单词中只包含小写英文字母。<br><strong>输出格式：</strong> 输出答案，或者为yes，或者为no。</p><blockquote><p><strong>样例输入：</strong> lanqiao<br><strong>样例输出：</strong> yes</p><p><strong>样例输入：</strong> world<br><strong>样例输出：</strong> no</p></blockquote><p><strong>评测用例规模与约定：</strong> 对于 <code>所有</code> 评测用例，单词中的字母个数不超过 <code>100</code>。</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>因为状态只有 <code>空 -&gt; 辅音 -&gt; 元音 -&gt; 辅音 -&gt; 元音</code> 五种状态，状态空间并不大，所以可以由 <code>0</code> 到 <code>4</code>列举出来。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 判断是否是元音bool isVowel(char ch){    return ch == &#39;a&#39; || ch == &#39;e&#39; || ch == &#39;i&#39; || ch == &#39;o&#39; || ch == &#39;u&#39;;}int main(){    string word;    cin &gt;&gt; word;    int state = 0;    for (int i = 0; i &lt; word.size(); i++)    {        if (state == 0)        {            if (!isVowel(word[i]))            {                state = 1;            }            else            {                break;            }        }        else if (state == 1)        {            if (isVowel(word[i]))            {                state = 2;            }        }        else if (state == 2)        {            if (!isVowel(word[i]))            {                state = 3;            }        }        else if (state == 3)        {            if (isVowel(word[i]))            {                state = 4;            }        }        else if (state == 4)        {            if (!isVowel(word[i]))            {                state = 5;                break; // 已超过题目要求，继续遍历无意义，可直接退出循环            }        }    }    cout &lt;&lt; ((state == 4) ? &quot;yes&quot; : &quot;no&quot;) &lt;&lt; endl;    return 0;}</code></pre><h4 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h4><p>原题是单词中辅音和元音状态转换 <code>4</code> 次，倘若改成转换 <code>n</code> 次，则不能一一列举，需要根据奇偶状态进行判断，将状态抽象出来。</p><p>抽象出函数如下：</p><pre><code class="lang-C++">bool isMatch(string word, int n){    if (n &lt;= 0)    {        return false;    }    int state = 0;    for (int i = 0; i &lt; word.size(); i++)    {        /*        注意，空状态state = 0和元音状态 state % 2 == 0是有区别的        空状态只能接辅音，而元音状态辅音元音都能接        */        if (state == 0)        {            if (!isVowel(word[i]))            {                state++;            }            else            {                break;            }        }        else if (state &gt; n)        {            break;        }        else        {            // 如果当前状态与下一个字母类型相反状态才变化            if ((state % 2 == 1 &amp;&amp; isVowel(word[i])) || (state % 2 == 0 &amp;&amp; !isVowel(word[i])))            {                state++;            }        }    }    return state == n;}</code></pre><h3 id="8-神奇序列"><a href="#8-神奇序列" class="headerlink" title="8. 神奇序列"></a>8. 神奇序列</h3><p><strong>问题描述：</strong> 小明想知道，满足以下条件的正整数序列的数量：</p><ol><li>第一项为 <code>n</code>；</li><li>第二项不超过 <code>n</code>；</li><li>从第三项开始，每一项小于前两项的差的绝对值。</li></ol><p>请计算，对于给定的 <code>n</code>，有多少种满足条件的序列。</p><p><strong>输入格式：</strong> 输入一行包含一个整数 <code>n</code>。<br><strong>输出格式：</strong> 输出一个整数，表示答案。答案可能很大，请输出答案除以 <code>10000</code> 的余数。</p><blockquote><p><strong>样例输入：</strong> 4<br><strong>样例输出：</strong> 7<br><strong>样例说明：</strong><br>以下是满足条件的序列：<br>4 1<br>4 1 1<br>4 1 2<br>4 2<br>4 2 1<br>4 3<br>4 4</p></blockquote><p><strong>评测用例规模与约定：</strong> 对于 <code>20%</code> 的评测用例，<code>1 &lt;= n &lt;= 5</code>；对于 <code>50%</code> 的评测用例，<code>1 &lt;= n &lt;= 10</code>；对于 <code>80%</code> 的评测用例，<code>1 &lt;= n &lt;= 100</code>；对于 <code>所有</code> 评测用例，<code>1 &lt;= n &lt;= 1000</code>。</p><h4 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h4><p>对于层层深入，我首先采用的是深度优先遍历（DFS）的算法，思路非常简单。</p><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int res = 0;void DFS(int first, int second){    for (int i = 1; i &lt; abs(first - second); i++)    {        res = (res + 1) % 10000;        DFS(second, i);    }}int main(){    int n;    cin &gt;&gt; n;    for (int second = 1; second &lt;= n; second++)    {        res++;        DFS(n, second);    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>对于思路1的算法，在 <code>n</code> 取到 <code>30</code> 时，耗费时间就已经是肉眼可见的慢了，对于 <code>n</code> 上限为 <code>1000</code> 的测试用例，这样的效率显然是无法接受的。</p><p>分析后猜想低效原因主要有两个，一个是调用 <code>DFS</code> 层数太深、次数太多，二是在前一部分搜索过的内容可能之后还会多次搜索（比如对于 <code>131</code> 来说，<code>13</code> 和 <code>31</code> 本质是一样的，但是前后搜索了两次）冗余程度较高。</p><p>从上面的分析可以联想到斐波那契数列（Fibonacci sequence），这两道题目有很高的相似性，想通了提高斐波那契数列时间效率对于本题或许就能迎刃而解。</p><p>斐波那契数列的定义如下：</p><script type="math/tex; mode=display">fib(x)=\left\{\begin{aligned}1, \quad & x = 1 & or && x = 2\\fib(x - 1) + fib(x - 2), \quad & {x \ge 2}\\\end{aligned}\right.</script><p>最直接的算法依然是 <code>DFS</code>。</p><pre><code class="lang-C++">int Fibonacci(int n){    return (n == 1 || n == 2) ? 1 : Fibonacci(n - 1) + Fibonacci(n - 2);}</code></pre><p><code>Fibonacci(40) = 102334155</code>，这个数字已经很大了，计算速度也非常慢。</p><p>此时可以进行优化，将已经搜索过的数字保存起来。保存数字最直接想到用数组，但是 <code>Fibonacci(n)</code> 只与前两项有关，故用两个常量保存即可。</p><pre><code class="lang-C++">int Fibonacci(int n){    if (n == 1 || n == 2)    {        return 1;    }    int a = 1, b = 1;    for (int i = 3; i &lt;= n; i++)    {        // 实现a = b, b = a + b        b += a;        a = b - a;    }    return b;}</code></pre><h4 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2"></a>思路2</h4><p>回到本题中来，设置二维数组v，<code>v[first][second]</code> 表示本位置前两个数为 <code>first</code> 和 <code>second</code> 时的序列数量。将搜索过的内容记录下来，后续需要时只需要调用即可。当 <code>n = 1000</code> 时得到结果比思路一要快得多。</p><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int DFS(vector&lt;vector&lt;int&gt; &gt; &amp;v, int first, int second){    int tmp = abs(first - second);    if (tmp &lt;= 1)    {        return 0;    }    if (v[first][second] != 0)    {        return v[first][second];    }    else    {        int res = 0;        for (int i = 1; i &lt; tmp; i++)        {            res = (res + 1 + DFS(v, second, i)) % 10000;        }        v[first][second] = v[second][first] = res;        return res;    }}int main(){    int n;    cin &gt;&gt; n;    vector&lt;vector&lt;int&gt; &gt; v(n + 1, vector&lt;int&gt;(n + 1, 0));    int res = 0;    for (int i = 1; i &lt;= n; i++)    {        res = (res + 1 + DFS(v, n, i)) % 10000;    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h3 id="9-草地延伸"><a href="#9-草地延伸" class="headerlink" title="9. 草地延伸"></a>9. 草地延伸</h3><p><strong>问题描述：</strong> 小明有一块空地，他将这块空地划分为 <code>n</code> 行 <code>m</code> 列的小块，每行和每列的长度都为 <code>1</code>。小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。请告诉小明，<code>k</code> 个月后空地上哪些地方有草。</p><p><strong>输入格式：</strong> 输入的第一行包含两个整数 <code>n</code>, <code>m</code>。接下来 <code>n</code> 行，每行包含 <code>m</code> 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 <code>g</code>，表示种了草。接下来包含一个整数 <code>k</code>。<br><strong>输出格式：</strong> 输出 <code>n</code> 行，每行包含 <code>m</code> 个字母，表示 <code>k</code> 个月后空地的状态。如果为小数点，表示为空地，如果字母为 <code>g</code>，表示长了草。</p><blockquote><p><strong>样例输入：</strong><br>4 5<br>.g…<br>…..<br>..g..<br>…..<br>2<br><strong>样例输出：</strong><br>gggg.<br>gggg.<br>ggggg<br>.ggg.</p></blockquote><p><strong>评测用例规模与约定：</strong>对于 <code>30%</code> 的评测用例，<code>2 &lt;= n</code>, <code>m &lt;= 20</code>。对于 <code>70%</code> 的评测用例，<code>2 &lt;= n</code>, <code>m &lt;= 100</code>。对于 <code>所有</code> 评测用例，<code>2 &lt;= n</code>, <code>m &lt;= 1000</code>，<code>1 &lt;= k &lt;= 1000</code>。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>广度优先遍历（BFS）一圈圈向外延展即可。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    char grass[n][m];    vector&lt;pair&lt;int, int&gt;&gt; v;    for (int i = 0; i &lt; n; i++)    {        string s;        cin &gt;&gt; s;        for (int j = 0; j &lt; m; j++)        {            grass[i][j] = s[j];            if (s[j] == &#39;g&#39;)            {                v.push_back(make_pair(i, j));            }        }    }    int k;    cin &gt;&gt; k;    // 当到达截止时间或无草可长时停止循环    for (int time = 0; time &lt; k &amp;&amp; !v.empty(); time++)    {        vector&lt;pair&lt;int, int&gt;&gt; next;        for (vector&lt;pair&lt;int, int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++)        {            int i = it-&gt;first, j = it-&gt;second;            if (i &gt;= 1 &amp;&amp; grass[i - 1][j] != &#39;g&#39;)            {                next.push_back(make_pair(i - 1, j));            }            if (i &lt;= n - 2 &amp;&amp; grass[i + 1][j] != &#39;g&#39;)            {                next.push_back(make_pair(i + 1, j));            }            if (j &gt;= 1 &amp;&amp; grass[i][j - 1] != &#39;g&#39;)            {                next.push_back(make_pair(i, j - 1));            }            if (j &lt;= m - 2 &amp;&amp; grass[i][j + 1] != &#39;g&#39;)            {                next.push_back(make_pair(i, j + 1));            }        }        for (vector&lt;pair&lt;int, int&gt;&gt;::iterator it = next.begin(); it != next.end(); it++)        {            grass[it-&gt;first][it-&gt;second] = &#39;g&#39;;        }        v = next; // 更新最外圈位置    }    for (int i = 0; i &lt; n; i++)    {        for (int j = 0; j &lt; m; j++)        {            cout &lt;&lt; grass[i][j];        }        cout &lt;&lt; endl;    }    return 0;}</code></pre><h3 id="10-好看晚会"><a href="#10-好看晚会" class="headerlink" title="10. 好看晚会"></a>10. 好看晚会</h3><p><strong>问题描述：</strong> 小明要组织一台晚会，总共准备了 <code>n</code> 个节目。然后晚会的时间有限，他只能最终选择其中的 <code>m</code> 个节目。这 <code>n</code> 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 <code>m</code> 个节目，满足他的要求。</p><p><strong>输入格式：</strong> 输入的第一行包含两个整数 <code>n</code>, <code>m</code> ，表示节目的数量和要选择的数量。第二行包含 <code>n</code> 个整数，依次为每个节目的好看值。<br><strong>输出格式：</strong> 输出一行包含 <code>m</code> 个整数，为选出的节目的好看值。</p><blockquote><p><strong>样例输入：</strong><br>5 3<br>3 1 2 5 4<br><strong>样例输出：</strong><br>3 5 4<br><strong>样例说明：</strong> 选择了第1, 4, 5个节目。</p></blockquote><p><strong>评测用例规模与约定：</strong> 对于 <code>30%</code> 的评测用例，<code>1 &lt;= n &lt;= 20</code>；对于 <code>60%</code> 的评测用例，<code>1 &lt;= n &lt;= 100</code>；对于 <code>所有</code> 评测用例，<code>1 &lt;= n &lt;= 100000</code>，<code>0 &lt;= 节目的好看值 &lt;= 100000</code>。</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>题目并不难，先将 <code>n</code> 个节目按好看程度排序，再将最好看的 <code>m</code> 个节目里按序号排序，输出前 <code>m</code> 个节目好看程度即可。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int number, look;    // 按好看程度排序函数    bool operator&lt;(const node &amp;y) const    {        if (look == y.look)            return number &lt;= y.number;        return look &gt; y.look;    }};// 最好看的m个节目里按序号排序函数bool cmp(const node &amp;x, const node &amp;y){    return x.number &lt; y.number;}int main(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    node a[n];    for (int i = 0; i &lt; n; i++)    {        int look;        cin &gt;&gt; look;        a[i].number = i + 1;        a[i].look = look;    }    sort(a, a + n);      // 按好看程度排序    sort(a, a + m, cmp); // 最好看的m个节目里按序号排序    for (int i = 0; i &lt; m; i++)    {        cout &lt;&lt; a[i].look &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
